"use strict";var a=(function(){function A(_,b,c){let s=_.createShader(c);_.shaderSource(s,b);_.compileShader(s);if(!_.getShaderParameter(s,_.COMPILE_STATUS)){let B=null;switch(c) {case _.VERTEX_SHADER:B='vertex';break;case _.FRAGMENT_SHADER:B='fragment';break}throw `[${B} compile]: ${_.getShaderInfoLog(s)}`}return s}return{generateMsdfShaderCode:function(){return{vertexCode:`
					#version 100

					precision mediump float;

					attribute vec2 position;
					attribute vec3 uv;

					uniform mat4 transform;
					uniform float fieldRange;
					uniform vec2 resolution;

					varying vec2 vUv;
					varying float vFieldRangeDisplay_px;

					void main() {
						vUv = uv.xy;

						// determine the field range in pixels when drawn to the framebuffer
						vec2 scale = abs(vec2(transform[0][0], transform[1][1]));
						float atlasScale = uv.z;
						vFieldRangeDisplay_px = fieldRange * scale.y * (resolution.y * 0.5) / atlasScale;
						vFieldRangeDisplay_px = max(vFieldRangeDisplay_px, 1.0);

						vec2 p = vec2(position.x * resolution.y / resolution.x, position.y);

						gl_Position = transform * vec4(p, 0.0, 1.0);
					}
				`,fragmentCode:`
					#version 100

					precision mediump float;     

					uniform vec4 color;
					uniform sampler2D glyphAtlas;

					uniform mat4 transform;

					varying vec2 vUv;
					varying float vFieldRangeDisplay_px;

					float median(float r, float g, float b) {
					    return max(min(r, g), min(max(r, g), b));
					}

					void main() {
						vec3 sample = texture2D(glyphAtlas, vUv).rgb;

						float sigDist = median(sample.r, sample.g, sample.b);

						// spread field range over 1px for antialiasing
						float fillAlpha = clamp((sigDist - 0.5) * vFieldRangeDisplay_px + 0.5, 0.0, 1.0);

						vec4 strokeColor = vec4(0.0, 1.0, 0.0, 0.0);
						float strokeWidthPx = 1.0;
						float strokeDistThreshold = clamp(strokeWidthPx * 2. / vFieldRangeDisplay_px, 0.0, 1.0);
						float strokeDistScale = 1. / (1.0 - strokeDistThreshold);
						float _offset = 0.5 / strokeDistScale;
						float strokeAlpha = clamp((sigDist - _offset) * vFieldRangeDisplay_px + _offset, 0.0, 1.0);
						
						gl_FragColor = (
							color * fillAlpha * color.a
							+ strokeColor * strokeColor.a * strokeAlpha * (1.0 - fillAlpha)
						);
						
						// to help debug stroke
						/**
						gl_FragColor =
							 vec4(vec3(sigDist), 0.) + strokeColor * strokeColor.a * strokeAlpha
							 // * (1.0 - fillAlpha)
						;
						/**/
					}
				`,vertexAttribute:{position:{name:'position',type:'vec2'},uv:{name:'uv',type:'vec3'}},uniform:{transform:{name:'transform',type:'mat4'},color:{name:'color',type:'vec4'},glyphAtlas:{name:'glyphAtlas',type:'sampler2D'},fieldRange:{name:'fieldRange',type:'float'},resolution:{name:'resolution',type:'vec2'}}}},createTextProgram:function(C,_b,_c,d){let e=a.generateMsdfShaderCode({});let p=C.createProgram();let g=A(C,_c||e.vertexCode,C.VERTEX_SHADER);let h=A(C,d||e.fragmentCode,C.FRAGMENT_SHADER);C.attachShader(p,g);C.attachShader(p,h);C.bindAttribLocation(p,0,'position');C.bindAttribLocation(p,1,'uv');C.linkProgram(p);C.deleteShader(g);C.deleteShader(h);if(!C.getProgramParameter(p,C.LINK_STATUS))throw `[program link]: ${C.getProgramInfoLog(p)}`;return{deviceHandle:p,attributeLocations:{position:0,uv:1},uniformLocations:{transform:C.getUniformLocation(p,e.uniform.transform.name),color:C.getUniformLocation(p,e.uniform.color.name),glyphAtlas:C.getUniformLocation(p,e.uniform.glyphAtlas.name),fieldRange:C.getUniformLocation(p,e.uniform.fieldRange.name),resolution:C.getUniformLocation(p,e.uniform.resolution.name)}}},deleteTextProgram:function(_a,D){_a.deleteProgram(D.deviceHandle);D.deviceHandle=null},createTextBuffer:function(_A,_B){let _C=_A.createBuffer();_A.bindBuffer(_A.ARRAY_BUFFER,_C);_A.bufferData(_A.ARRAY_BUFFER,_B.vertexArray,_A.STATIC_DRAW);return{deviceHandle:_C,vertexCount:_B.vertexCount,vertexLayout:_B.vertexLayout,drawMode:_A.TRIANGLES,frontFace:_A.CCW}},deleteTextBuffer:function(E,aA){E.deleteBuffer(aA.deviceHandle);aA.deviceHandle=null},createGlyphAtlas:function(aB,aC){let aD=aB.createTexture();aB.bindTexture(aB.TEXTURE_2D,aD);aB.pixelStorei(aB.UNPACK_FLIP_Y_WEBGL,!1);aB.pixelStorei(aB.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);aB.texImage2D(aB.TEXTURE_2D,0,aB.RGBA,aB.RGBA,aB.UNSIGNED_BYTE,aC);aB.texParameteri(aB.TEXTURE_2D,aB.TEXTURE_WRAP_S,aB.CLAMP_TO_EDGE);aB.texParameteri(aB.TEXTURE_2D,aB.TEXTURE_WRAP_T,aB.CLAMP_TO_EDGE);aB.texParameteri(aB.TEXTURE_2D,aB.TEXTURE_MIN_FILTER,aB.LINEAR_MIPMAP_LINEAR);aB.texParameteri(aB.TEXTURE_2D,aB.TEXTURE_MAG_FILTER,aB.LINEAR);aB.generateMipmap(aB.TEXTURE_2D);return aD},deleteGlyphAtlas:function(aE,aF){aE.deleteTexture(aF)}}})();typeof module!='undefined'&&module.exports!=null&&(module.exports=a);
