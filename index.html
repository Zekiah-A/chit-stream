<!DOCTYPE html>
<html>
<head>
    <title>Chit-Stream</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0px;
            padding: 0px;
            overflow-y: auto;
            overflow-x: hidden;
            top: 0;
            left: 0;
            position: absolute;
            width: 100%;
            height: 100%;
            font-family: Arial, Helvetica, sans-serif;
            background-image: url(./creo.png);
            color: white;
        }
        .stream-views {
            display: flex;
            column-gap: 8px;
            align-items: center;
        }
        .vid-container {
            position: relative;
            border: 1px solid gray;
            box-shadow: 0px 0px 4px gray;
            display: inline-block;
            min-height: 320px;
            border-radius: 8px;
            overflow: clip;
        }
        .vid-container > div {
            position: absolute;
            left: 0;
            bottom: 0;
            background: #626262a3;
            padding: 4px;
            border-radius: 0px 8px 0px 0px;
            color: white;
            backdrop-filter: blur(5px);
        }

        .pipeline-section {
            min-width: 256px;
            display: flex;
            flex-direction: column;
            align-self: stretch;
        }
        .pipeline-container {
            flex-grow: 1;
            padding: 8px;
            flex-direction: row;
            column-gap: 8px;
            display: flex;
            position: relative;
        }
        .pipeline-item {
            padding: 8px;
            border: 1px solid #ffffff3b;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            background: linear-gradient(to bottom right, #fff0 80%, #b5b2b275);
        }
        .dropdown {
            position: absolute;
            margin: 0px;
            padding-left: 0;
            border-radius: 4px;
            backdrop-filter: blur(8px);
            box-shadow: 0px 0px 8px #404040;
            padding-right: 0;
            padding-top: 8px;
            padding-bottom: 8px;
            display: flex;
            list-style-type: none;
            width: max-content;
            z-index: 1;
        }
        .dropdown > li {
            user-select: none;
            padding-left: 16px;
            padding-right: 16px;
            padding-top: 8px;
            padding-bottom: 8px;
        }
        .dropdown > li:hover {
            background-color: #e3e3e33e;
        }
        .dropdown-title {
            margin-left: 8px;
            margin-top: 0px;
            margin-bottom: 0px;
            user-select: none;
        }
    </style>
    <script>var exports = {};</script>
    <script src="./lib/gputext.min.js"></script>
    <script src="./lib/gputext-webgl.min.js"></script>
    <script src="./lib/van-1.2.4.nomodule.min.js"></script>
</head>
<body>
    <div class="stream-views">
        <div class="vid-container">
            <video id="rawPreviewVideo" autoplay></video>
            <div>Raw source video</div>
        </div>
        <div class="pipeline-section" id="pipelineSection">
            <span>Render pipeline</span>
        </div>
        <div class="vid-container">
            <canvas id="previewCanvas" autoplay></canvas>
            <div>Stream composite preview</div>
        </div>
    </div>
    <button onclick="startStream()">Start streaming</button>
    <button onclick="watchStream()">Start watching</button>
</body>
<script>
    const { button, div, li, ul, h4, p, input } = van.tags
    const gl = previewCanvas.getContext("webgl2")
    const ws = new WebSocket("ws://localhost:3000")
    ws.binaryType = "arraybuffer"

    // Standard shader methods
	function loadShader(gl, type, source) {
		const shader = gl.createShader(type)
		gl.shaderSource(shader, source)
		gl.compileShader(shader)
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			console.error(`Failed to compile shader: ${gl.getShaderInfoLog(shader)}`)
			gl.deleteShader(shader)
			return null
		}

		return shader
	}

	function compileShaderProgram(gl, vertexSource, fragmentSource) {
		const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vertexSource)
		const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fragmentSource)

		const program = gl.createProgram()
		gl.attachShader(program, vertexShader)
		gl.attachShader(program, fragmentShader)
		gl.linkProgram(program)

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			console.error(`Failed to init shader: ${gl.getProgramInfoLog(program,)}`)
			return null
		}
		
		return program
	}

    function bindBufferPositionAttrib(gl, buffer, vertexPositionAttrib) {
        const components = 2
        const type = gl.FLOAT
        const normalize = false
        const stride = 0 // Ignore, use components & type to determine byte stride
        const offset = 0 // Start from buffer start

        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.vertexAttribPointer(vertexPositionAttrib, components, type, normalize, stride, offset)
        gl.enableVertexAttribArray(vertexPositionAttrib)
    }

    function createPositionBuffer(positionsArr) {
        const buffer = gl.createBuffer()
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionsArr), gl.STATIC_DRAW)

        return buffer
    }

    // Effect shader definitions
    class StandardEffect {
        #videoTexture

        constructor() {
            this.vertex = `
                attribute vec4 a_vertexPosition;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;

                void main()
                {
                    gl_Position = a_vertexPosition;
                    v_texCoord = a_texCoord;
                }
            `
            this.fragment = `
                precision mediump float;
                uniform sampler2D u_videoTexture;
                varying vec2 v_texCoord;

                void main()
                {
                    gl_FragColor = texture2D(u_videoTexture, v_texCoord);
                }
            `
            this.#videoTexture = null
        }

        set videoTexture(value) {
            if (this.videoTextureAttrib) {
                this.#videoTexture = value
                gl.uniform1i(this.videoTextureAttrib, value)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }
        get videoTexture() {
            return this.#videoTexture
        }

        exposes() {
            return div("This effect can't be configured :(")
        }

        bindAttribs() {
            this.vertexPosAttrib = gl.getAttribLocation(this.program, "a_vertexPosition")
            this.vertexPosBuffer = createPositionBuffer([ 1.0,1.0, -1.0,1.0, 1.0,-1.0, -1.0,-1.0 ])
            bindBufferPositionAttrib(gl, this.vertexPosBuffer, this.vertexPosAttrib)

            this.texCoordAttrib = gl.getAttribLocation(this.program, "a_texCoord")
            this.texCoordBuffer = createPositionBuffer([ 1.0,0.0, 0.0,0.0, 1.0,1.0, 0.0,1.0 ]) // UV coordinates, BL, BR, TL, TR
            bindBufferPositionAttrib(gl, this.texCoordBuffer, this.texCoordAttrib)

            this.videoTextureAttrib = gl.getUniformLocation(this.program, "u_videoTexture")
            gl.uniform1i(this.videoTextureAttrib, this.#videoTexture)
        }
    }

    class ImplosionEffect extends StandardEffect {
        #implosionCenter
        #implosionStrength

        constructor() {
            super()
            this.fragment = `
                precision mediump float;
                uniform sampler2D u_videoTexture;
                varying vec2 v_texCoord;

                uniform vec2 u_implosionCenter;
                uniform float u_implosionStrength;

                void main()
                {
                    // Calculate the vector from the current fragment to the implosion center
                    vec2 offset = v_texCoord - u_implosionCenter;
                    
                    // Calculate the distance from the implosion center
                    float distance = length(offset);
                    
                    // Apply the implosion effect
                    vec2 distortedTexCoord = v_texCoord - (offset * (1.0 / (1.0 + u_implosionStrength * distance)));

                    gl_FragColor = texture2D(u_videoTexture, distortedTexCoord);
                }
            `
            this.#implosionCenter = { x: 0.5, y: 0.5 }
            this.#implosionStrength = 1
        }

        set implosionCenter(value) {
            if (this.implosionCenterAttrib) {
                this.#implosionCenter = value
                gl.uniform2f(this.implosionCenterAttrib, value.x, value.y)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }
        get implosionCenter() {
            return this.#implosionCenter
        }

        set implosionStrength(value) {
            if (this.implosionStrengthAttrib) {
                this.#implosionStrength = value
                gl.uniform1f(this.implosionStrengthAttrib, value)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }
        get implosionStrength() {
            return this.#implosionStrength
        }

        bindAttribs() {
            super.bindAttribs()
            this.implosionCenterAttrib = gl.getUniformLocation(this.program, "u_implosionCenter");
            gl.uniform2f(this.implosionCenterAttrib, this.#implosionCenter.x, this.#implosionCenter.y) 

            this.implosionStrengthAttrib = gl.getUniformLocation(this.program, "u_implosionStrength")
            gl.uniform1f(this.implosionStrengthAttrib, this.#implosionStrength)
        }
    }

    class SkinSmoothEffect extends StandardEffect {
        constructor() {
            super()
            this.fragment = `
                vec4 gaussian()
                {
                    float pi2 = 6.28318530718;
        
                    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)
                    float Quality = 3.0; // BLUR QUALITY (Default 4.0 - More is better but slower)
                    float Size = 8.0; // BLUR SIZE (Radius)
                
                    vec2 Radius = Size / iResolution.xy;
                    
                    // Normalized pixel coordinates (from 0 to 1)
                    vec2 uv = fragCoord / iResolution.xy;
                    // Pixel colour
                    vec4 Color = texture(iChannel0, uv);
                    
                    // Blur calculations
                    for (float d=0.0; d < pi2; d += pi2 / Directions)
                    {
                        for (float i = 1.0 / Quality; i <= 1.0; i += 1.0 / Quality)
                        {
                            Color += texture(iChannel0, uv+vec2(cos(d), sin(d)) * Radius * i);		
                        }
                    }
                    
                    Color /= Quality * Directions - 15.0;
                    fragColor =  Color;
                }

                vec4 overlay(vec4 a, vec4 b)
                {
                    vec4 x = vec4(2.0) * a * b;
                    vec4 y = vec4(1.0) - vec4(2.0) * (vec4(1.0)-a) * (vec4(1.0)-b);
                    vec4 result;
                    result.r = mix(x.r, y.r, float(a.r > 0.5));
                    result.g = mix(x.g, y.g, float(a.g > 0.5));
                    result.b = mix(x.b, y.b, float(a.b > 0.5));
                    result.a = mix(x.a, y.a, float(a.a > 0.5));
                    return result;
                }
            `
        }

        bindAttribs() {
            super.bindAttribs()
        }
    }

    class FilterEffect extends StandardEffect {
        #brightness
        #contrast
        #saturation
        #hue

        constructor() {
            super()
            this.fragment = `
                precision mediump float;

                uniform sampler2D u_videoTexture;
                uniform float u_brightness;
                uniform float u_contrast;
                uniform float u_saturation;
                uniform float u_hue;

                varying vec2 v_texCoord;

                void main() {
                    vec4 color = texture2D(u_videoTexture, v_texCoord);

                    // Adjust brightness
                    color.rgb += (u_brightness - 1.0);

                    // Adjust contrast
                    color.rgb = (color.rgb - 0.5) * u_contrast + 0.5;

                    // Adjust saturation
                    float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                    color.rgb = mix(vec3(gray), color.rgb, u_saturation);

                    // Adjust hue
                    /*float angle = u_hue * 3.14159265359; // Convert hue to radians
                    float s = sin(angle);
                    float c = cos(angle);
                    vec3 rgb = vec3(
                        c + (1.0 - c) / 3.0,
                        1.0 / 3.0 * (1.0 - c) - sqrt(1.0 / 3.0) * s,
                        1.0 / 3.0 * (1.0 - c) + sqrt(1.0 / 3.0) * s
                    );
                    color.rgb = mat3(
                        rgb.x, rgb.x, rgb.x,
                        rgb.z, rgb.x - 2.0 * rgb.z, rgb.z,
                        rgb.z, rgb.z, rgb.y
                    ) * color.rgb;*/

                    gl_FragColor = color;
                }
            `
            this.#brightness = 1.0
            this.#contrast = 1.0
            this.#saturation = 1.0
            this.#hue = 0.0
        }

        set brightness(value) {
            if (this.brightnessAttrib) {
                this.#brightness = value
                gl.uniform1f(this.brightnessAttrib, value)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }

        set contrast(value) {
            if (this.contrastAttrib) {
                this.#contrast = value
                gl.uniform1f(this.contrastAttrib, value)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }

        set saturation(value) {
            if (this.saturationAttrib) {
                this.#saturation = value
                gl.uniform1f(this.saturationAttrib, value)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }

        set hue(value) {
            if (this.hueAttrib) {
                this.#hue = value
                gl.uniform1f(this.hueAttrib, value)
            }
            else throw new Error("Shader effect must be bound first with attribute")
        }

        exposes() {
            return div(
                "Contrast",
                input({type: "range", step: "any", min: "0", max: "2", value: this.#contrast, oninput: (e) => this.#contrast = e.target.value})
            )
        }

        bindAttribs() {
            super.bindAttribs()
            this.brightnessAttrib = gl.getUniformLocation(this.program, "u_brightness");
            gl.uniform1f(this.brightnessAttrib, this.#brightness)
            this.contrastAttrib = gl.getUniformLocation(this.program, "u_contrast")
            gl.uniform1f(this.contrastAttrib, this.#contrast)
            this.saturationAttrib = gl.getUniformLocation(this.program, "u_saturation")
            gl.uniform1f(this.saturationAttrib, this.#saturation)
            this.hueAttrib = gl.getUniformLocation(this.program, "u_hue")
            gl.uniform1f(this.hueAttrib, this.#hue)
        }
    }

    class ImageOverlay extends StandardEffect {
        constructor() {
            super()
            this.vertex = `
                attribute vec4 a_vertexPosition;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;

                void main()
                {
                    gl_Position = a_vertexPosition;
                    v_texCoord = a_texCoord;
                }
            `
            this.fragment = `
                precision mediump float;
                uniform sampler2D u_videoTexture;
                varying vec2 v_texCoord;

                void main()
                {
                    gl_FragColor = texture2D(u_videoTexture, v_texCoord);
                }
            `
            this.image = null
            this.transform = [ 1.0,1.0, -1.0,1.0, 1.0,-1.0, -1.0,-1.0 ]
        }
    }

    const effectShaders = {
        standard: StandardEffect,
        implosion: ImplosionEffect,
        filter: FilterEffect
    }

    const overlayShaders = {
        image: ImageOverlay
    }

    function useEffectShader(shaderDefinition) {
        let program = shaderDefinition.program
        if (!program) {
            program = compileShaderProgram(gl, shaderDefinition.vertex, shaderDefinition.fragment)
            shaderDefinition.program = program
            gl.useProgram(program)
            shaderDefinition.bindAttribs()
        }
        else {
            gl.useProgram(program)
        }
        return shaderDefinition
    }

    class PipelineState {
        constructor(effectOverlays = []) {
            this.effectOverlays = effectOverlays
        }
        add(effectOverlay) {
            this.effectOverlays.push(effectOverlay)
            return new PipelineState(this.effectOverlays)
        }
        load() {
            // TODO: Later
            return new PipelineState()
        }
    }

    const EffectOverlayPipeline = (pipeline) => {
        const pipelineState = van.state(pipeline)

        const EffectOverlayItem = (effectOverlay) => {
            return div({class: "pipeline-item"},
                h4({class:"dropdown-title"}, effectOverlay.constructor.name),
                effectOverlay.exposes()
            )
        }

        const dropdown = ul({
                class: "dropdown",
                style: "display: none;",
                onmouseleave: e => dropdown.style.display = "none"
            },
            h4({class:"dropdown-title"}, "Create effect"),
            Object.keys(effectShaders)
                .map(name => li({onclick: e => {
                    pipelineState.val = pipelineState.val.add(new effectShaders[name]())
                    dropdown.style.display = "none"
                }}, name[0].toUpperCase() + name.slice(1) + " effect")),
            h4({class:"dropdown-title"}, "Create overlay"),
            Object.keys(overlayShaders)
                .map(name => li({onclick: e => {
                    aa = pipelineState.val
                    pipelineState.val = pipelineState.val.add(new overlayShaders[name]())
                    dropdown.style.display = "none"
                }}, name[0].toUpperCase() + name.slice(1) + " overlay")),
        )
        
        const pipelineContainer = div({class: "pipeline-container"},
            // TODO: fix this
            () => div({style: "display: flex;"}, pipelineState.val.effectOverlays.map(EffectOverlayItem)),
            button({
                onclick: e => {
                    dropdown.style.display = "block"
                    dropdown.style.left = (e.offsetX + e.target.offsetLeft + 8) + "px"
                    dropdown.style.top = (e.offsetY + e.target.offsetTop + 8) + "px"
                },
                style: "height: 64px; align-self: center; position: relative;"
            }, "+ Add new"),
        )

        van.add(pipelineContainer, dropdown)
        return pipelineContainer
    }

    const pipeline = new PipelineState()
    van.add(pipelineSection, EffectOverlayPipeline(pipeline))
    
    // Stream methods
    async function startStream() {
        if (!navigator.mediaDevices.getUserMedia) {
            alert("Error - Available camera device needed!")
            return
        }
        const stream = await navigator.mediaDevices.getUserMedia({ video: true }).catch(e => {})
        if (stream == null) {
            alert("Error - Failed acquiring permissions!")
            return
        }

        gl.clear(gl.COLOR_BUFFER_BIT)

        rawPreviewVideo.srcObject = stream
        rawPreviewVideo.addEventListener("play", () => {
            const width = rawPreviewVideo.videoWidth
            const height = rawPreviewVideo.videoHeight
            previewCanvas.width = width
            previewCanvas.height = height

            const videoTexture = gl.createTexture()
            gl.bindTexture(gl.TEXTURE_2D, videoTexture)
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255]))

            // Fill space with GL
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)

            let frame = 0
            function captureFrame() {
                const currentEffect = useEffectShader(effectShaders.filter)
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

                gl.activeTexture(gl.TEXTURE0)
                gl.bindTexture(gl.TEXTURE_2D, videoTexture)
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, rawPreviewVideo)
                currentEffect.videoTexture = 0

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)

                const imageData = new Uint8Array(width * height * 4)
                gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, imageData)
                const binaryData = new Uint8Array(imageData.buffer)
                const packet = new Uint8Array(binaryData.byteLength + 1)
                packet.set(binaryData, 1)
                ws.send(packet)

                requestAnimationFrame(captureFrame)
                frame++
            }
            captureFrame()
        })

        console.log("Started streaming")
    }

    async function watchStream() {
        let imageData = null

        ws.onmessage = async function({ data }) {
            const u8Data = new Uint8ClampedArray(data)

            switch (u8Data[0]) {
                case 0: {
                    let width = 1280
                    let height = 720
                    let fps = 0

                    canvas.width = width
                    canvas.height = height
                    
                    const dummyFrame = new Uint8ClampedArray(width * height * 4)
                    imageData = new ImageData(dummyFrame, width, height)
                    rawPreviewVideo.srcObject = canvas.captureStream(fps)
                    break
                }
                case 1: {
                    imageData.data.set(u8Data.subarray(1), 0) 
                    context.putImageData(imageData, 0, 0)
                    break
                }
            }
        }

        console.log("Started observing stream")
    }
</script>
</html>
